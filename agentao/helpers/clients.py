import logging
import os
from datetime import datetime
from logging import Logger
import posthog
import pytz
from dotenv import load_dotenv
from enum import Enum
from dataclasses import dataclass, asdict
from typing import Any, Dict, Optional

load_dotenv()

class LifecycleEvents(Enum):
    QUESTION_GENERATED = "question_generated"
    MINER_SUBMITTED = "miner_submitted"
    SOLUTION_SELECTED = "solution_selected"

    @classmethod
    def get_required_props(cls, event):
        props_map = {
            cls.QUESTION_GENERATED: ["question_id", "question_text", "created_at"],
            cls.MINER_SUBMITTED: ["question_id", "miner_hotkey", "submitted_at"],
            cls.SOLUTION_SELECTED: ["question_id", "grade", "miner_hotkey", "selected_at"]
        }
        return props_map.get(event, [])

class LogType(Enum):
    INTERNAL = "internal"
    LIFECYCLE = "lifecycle"

@dataclass
class LogSessionContext:
    actor_id: str
    actor_type: str
    session_id: str # This is generated by the client when it starts, and is used to identify the session in PostHog
    is_mainnet: bool
    log_version: int

    def to_dict(self):
        return asdict(self)

def validate_lifecycle_event(event_type: LifecycleEvents, properties: Dict[str, Any]) -> bool:
    if not event_type or not isinstance(event_type, LifecycleEvents):
        return False
    
    required_props = LifecycleEvents.get_required_props(event_type)
    if not properties or not all(prop in properties for prop in required_props):
        return False
    
    return True

@dataclass
class LogContext:
    log_type: LogType
    event_type: Optional[LifecycleEvents]
    additional_properties: Optional[Dict[Any, Any]] = None
    
    def __post_init__(self):
        if self.log_type == LogType.LIFECYCLE and not self.event_type:
            raise ValueError("Event type must be provided for lifecycle events")

        if self.log_type == LogType.LIFECYCLE and not validate_lifecycle_event(self.event_type, self.additional_properties):
            raise ValueError("Properties do not match the expected format for the event type")
        
        return True

    def to_dict(self):
        base_dict = asdict(self)
        base_dict['log_type'] = self.log_type.value
        if self.additional_properties:
            base_dict.update(self.additional_properties)
        return base_dict

class ESTFormatter(logging.Formatter):
    def formatTime(self, record, datefmt=None):
        est = pytz.timezone("America/New_York")
        ct = datetime.fromtimestamp(record.created, est)
        return ct.strftime("%Y-%m-%d %H:%M:%S")

    def format(self, record):
        # Pad the level name to 5 characters
        record.levelname = f"{record.levelname:<5}"
        return super().format(record)


formatter = ESTFormatter('%(asctime)s - %(filename)s:%(lineno)d [%(levelname)s] %(message)s')

class AgentaoLogger:
    def __init__(self, base_logger: logging.Logger):
        self.logger = base_logger
        self._context: Optional[LogSessionContext] = None

    def set_context(self, context: LogSessionContext):
        """Set the context for subsequent log messages"""
        self._context = context

    def _log(self, level: int, message: str, event_id: Optional[str] = None, 
             additional_properties: Optional[Dict] = None):
        if not self._context:
            raise ValueError("Logger context not set. Call set_context() first.")

        properties = self._context.to_dict()
        if additional_properties:
            properties.update(additional_properties)

        if self.logger.posthog_enabled:
            record = logging.LogRecord(
                name=self.logger.name,
                level=level,
                pathname="",
                lineno=0,
                msg=message,
                args=(),
                exc_info=None
            )
            record.event_id = event_id or message
            record.properties = properties
            record.distinct_id = self._context.actor_id
            
            # Find and use PostHog handler
            for handler in self.logger.handlers:
                if isinstance(handler, PostHogHandler):
                    handler.emit(record)

        # Always log to console with context
        context_str = f"[{self._context.actor_type}:{self._context.actor_id}] "
        self.logger.log(level, context_str + message)

    def lifecycle_event(self, message: str, context: LogContext):
        """Log lifecycle events (only for validators)"""
        if self._context.actor_type != "validator":
            raise ValueError("Lifecycle events can only be emitted by validators")
        
        if context.log_type != LogType.LIFECYCLE:
            raise ValueError("Logger context must be set to LIFECYCLE for lifecycle events")
        
        # Validate the properties for a lifecycle event
        if not validate_lifecycle_event(context.event_type, context.additional_properties):
            raise ValueError("Properties do not match the expected format for the event type")

        self._log(
            level=logging.INFO,
            message=message,
            event_id=context.event_type.value,
            additional_properties=context.additional_properties
        )

    def debug(self, message: str, properties: Optional[Dict] = None):
        """Internal debug log"""
        if self._context.log_type != LogType.INTERNAL:
            raise ValueError("Logger context must be set to INTERNAL for debug logs")
        self._log(logging.DEBUG, message, additional_properties=properties)

    def info(self, message: str, properties: Optional[Dict] = None):
        """Internal info log"""
        if self._context.log_type != LogType.INTERNAL:
            raise ValueError("Logger context must be set to INTERNAL for info logs")
        self._log(logging.INFO, message, additional_properties=properties)

    def warning(self, message: str, properties: Optional[Dict] = None):
        """Internal warning log"""
        if self._context.log_type != LogType.INTERNAL:
            raise ValueError("Logger context must be set to INTERNAL for warning logs")
        self._log(logging.WARNING, message, additional_properties=properties)

    def error(self, message: str, properties: Optional[Dict] = None):
        """Internal error log"""
        if self._context.log_type != LogType.INTERNAL:
            raise ValueError("Logger context must be set to INTERNAL for error logs")
        self._log(logging.ERROR, message, additional_properties=properties)

# Get all built-in LogRecord attributes by creating a dummy record and getting its __dict__ keys
LOG_RECORD_BUILTIN_ATTRS = list(logging.LogRecord("", 0, "", 0, "", (), None).__dict__.keys())

class AgentaoHandler(logging.Handler):
    def __init__(self, context: LogSessionContext):
        super().__init__()
        self.setFormatter(formatter)
        self._context = context

        self._posthog_enabled = False

        if os.environ.get("POSTHOG_KEY") and os.environ.get("POSTHOG_HOST"):
            try:
                posthog.api_key = os.environ["POSTHOG_KEY"]
                posthog.host = os.environ["POSTHOG_HOST"]
                self._posthog_enabled = True
            except Exception as e:
                print(f"Failed to initialize PostHog handler: {e}")
                self._posthog_enabled = False
    
    def emit(self, record):
        if self._posthog_enabled == False:
            return 
        
        try:
            description = self.format(record)
            properties = {}

            for key, val in record.__dict__.items():
                if key not in LOG_RECORD_BUILTIN_ATTRS:
                    properties[key] = val

            if self._posthog_enabled:
                event_type = properties.get("log_type")

                if event_type == LogType.LIFECYCLE.value:
                    if not properties.get("event_type") or properties.get("event_type") not in [LifecycleEvents.MINER_SUBMITTED.value, LifecycleEvents.QUESTION_GENERATED.value, LifecycleEvents.SOLUTION_SELECTED.value]:
                        raise ValueError(f"Invalid event type: {properties.get('event_type') or ''}")
                    # Validate the properties for a lifecycle event 
                    if not validate_lifecycle_event(properties.get("event_type"), properties):
                        raise ValueError("Properties do not match the expected format for the event type")
                    
                    if not self._context.actor_type == "validator":
                        raise PermissionError("Only validators can post lifecycle events.")
                    
                    posthog.capture(
                        distinct_id=self._context.actor_id,
                        event=record.event_id,
                        properties=properties
                    )
                elif event_type == LogType.INTERNAL.value:
                    formatted_properties = {
                        "description": description,
                        **properties
                    }
                    
                    posthog.capture(
                        distinct_id=self._context.actor_id,
                        event=record.event_id,
                        properties=formatted_properties
                    )

                else:
                    raise ValueError(f"Invalid log type: {event_type}")

                posthog.flush()
        except Exception:
            self.handleError(record)

class PostHogHandler(logging.Handler):
    def __init__(self):
        super().__init__()
        self.setFormatter(formatter)

    def emit(self, record):
        try:
            event_id = getattr(record, 'event_id', None) or record.getMessage()
            description = self.format(record)  # Use formatter to format the message
            properties = getattr(record, 'properties', {})
            distinct_id = getattr(record, 'distinct_id', 'anonymous')
            event_properties = {
                'description': description,
                **properties
            }
            print('logging to posthog', event_id, event_properties)
            posthog.capture(
                distinct_id=distinct_id,
                event=event_id,
                properties=event_properties
            )
            posthog.flush()  # Force PostHog to push events immediately
        except Exception:
            self.handleError(record)


def setup_logger() -> Logger:
    # Clear any existing handlers to avoid conflicts
    logger = logging.getLogger(__name__)
    if logger.hasHandlers():
        logger.handlers.clear()

    logger.setLevel(logging.DEBUG)

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Add PostHog handler if environment variables are set
    posthog_enabled = False
    if os.environ.get("POSTHOG_KEY") and os.environ.get("POSTHOG_HOST"):
        try:
            posthog.api_key = os.environ["POSTHOG_KEY"]
            posthog.host = os.environ["POSTHOG_HOST"]
            logger.addHandler(PostHogHandler())
            posthog_enabled = True
        except Exception as e:
            logger.warning(f"Failed to initialize PostHog handler: {e}")

    # Attach the posthog_enabled flag to the logger
    logger.posthog_enabled = posthog_enabled
    return logger


def setup_x_logger(logger_name: str, log_session_context: LogSessionContext) -> Logger:
    logger = logging.getLogger(logger_name)

    if logger.hasHandlers():
        logger.handlers.clear()

    logger.setLevel(logging.DEBUG)

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    
    logger.addHandler(console_handler)
    logger.addHandler(AgentaoHandler(context=log_session_context))

    return logger

# Initialize the shared logger
LOGGER = setup_logger()

# cls.QUESTION_GENERATED: ["question_id", "question_text", "created_at"],
# cls.MINER_SUBMITTED: ["question_id", "miner_hotkey", "submitted_at"],
# cls.SOLUTION_SELECTED: ["question_id", "grade", "miner_hotkey", "selected_at"]

if __name__ == "__main__":
    log_session_context = LogSessionContext(
        actor_id="1289",
        actor_type="validator",
        session_id="1000",
        is_mainnet=False,
        log_version=4,
    )

    example_log = LogContext(
        log_type=LogType.INTERNAL,
        event_type=None,
        additional_properties={
            "some key", "additional value"
        }
    )

    my_logger: Logger = setup_x_logger(logger_name="validator_n", log_session_context=log_session_context)

    example_lifecycle_context = LogContext(
        log_type=LogType.LIFECYCLE,
        event_type=LifecycleEvents.QUESTION_GENERATED,
        additional_properties={"question_text": "What is the capital of Mexico?", "question_id": "123", "created_at": datetime.now()}
    )

    my_logger.info("this is a test of the new log version", extra={
        "log_type": "internal",
        "some key": "some value",
        "event_id": "some vent id"
    })

    # query_all_logs()

# Integrate logging into the rest of the codebase
# Setup ingestion and grouping on frontend that makes senese
# Create trpc screens